//For Text changeimport fl.transitions.Tween;import fl.transitions.easing.*;import fl.transitions.TweenEvent;import flash.text.Font;var perlinData:BitmapData;var parameterTween:Tween;var dmf:DisplacementMapFilter;var blur:BlurFilter;var maxDisplacementX:Number;var maxDisplacementY:Number;var maxBlurX:Number;var maxBlurY:Number;var even:Boolean;var tweenDuration:Number;var holdDuration_ms:Number;var holdTimer:Timer;var textHolder:Sprite;var textFields:Vector.<TextField>;var strings:Vector.<String>;var sizes:Vector.<int>;var colors:Vector.<uint>;var red:Vector.<Number>;var green:Vector.<Number>;var blue:Vector.<Number>;var r0,g0,b0,r1,g1,b1:Number;var colorTrans:ColorTransform;var from:int;var to:int;var num:int;var alphaDelay:Number;var m0:Number;var m1:Number;var xint0:Number;var xint1:Number;var perlinBaseX:Number;var perlinBaseY:Number;var octaves:int;var paramObj:Object = {t:0};//we are using embedded fonts which allows antialiasing, for better appearance. We have to register the font contained in the library.Font.registerFont(Arial);init();function init():void {	textFields = new Vector.<TextField>();		//enter the desired strings and the text sizes in the vectors below.	strings = new <String>["Drop the Bass", "This song is sweet","Wait for the Next drop","I Hope You Enjoy this Site",						    ];	sizes = new <int>[24, 16, 16, 32, ];	colors = new <uint>[0xd00000, 0xffff88, 0x66DDFF, 0x88FF88];		num = strings.length;	//set up colors:	red = new Vector.<Number>();	green = new Vector.<Number>();	blue = new Vector.<Number>();	var i:int;	for (i = 0; i < num; i++) {		red.push(colors[i] >> 16);		green.push((colors[i] >> 8) & 0xFF);		blue.push(colors[i] & 0xFF);	}		colorTrans = new ColorTransform(0,0,0,1,red[0],green[0],blue[0],0);			//This is how long to wait during the tween (from 0 to 1) before the alpha starts changing:	alphaDelay = 0.1;	//these constants will be used for the alpha change:	m0 = 1/(2*alphaDelay-1);	m1 = -m0;	xint0 = 1-alphaDelay;	xint1 = alphaDelay;		//duration for the tween, in frames:	tweenDuration = 36;	//duration for the hold time between tweens, in milliseconds:	holdDuration_ms = 1000;		//A DisplacementMapFilter and a BlurFilter are used for the transition. Below are the maximum amounts to use for	//the displacement and blur during the transition.	maxDisplacementX = maxDisplacementY = 170;	maxBlurX = maxBlurY = 20;	perlinBaseX = perlinBaseY = 100;	octaves = 3;		textHolder = new Sprite();	this.addChild(textHolder);	textHolder.x = 275;	textHolder.y = 120;		textHolder.transform.colorTransform = colorTrans;		setUptextFields();					perlinData = new BitmapData(480,250,false);	generatePerlinNoise();		dmf = new DisplacementMapFilter(perlinData, new Point(0,-50), BitmapDataChannel.BLUE, BitmapDataChannel.RED, maxDisplacementX, maxDisplacementY, DisplacementMapFilterMode.COLOR, 0x000000, 0);	blur = new BlurFilter(maxBlurX,maxBlurY);			from = 0;	to = 1;		textFields[0].alpha = 1;		holdTimer = new Timer(holdDuration_ms,1);	holdTimer.addEventListener(TimerEvent.TIMER_COMPLETE, startTween);	holdTimer.start();}function setUptextFields():void {	var num:int = strings.length;	var i:int;	for (i = 0; i < num; i++) {		var tf:TextField = new TextField();		tf.embedFonts = true;		tf.antiAliasType = AntiAliasType.ADVANCED;		var format:TextFormat = new TextFormat("Arial", sizes[i], 0xFFFFFF);		tf.defaultTextFormat = format;		tf.autoSize = TextFieldAutoSize.CENTER;		tf.text = strings[i];		 		tf.x = -tf.width/2;		tf.y = -tf.height/2;				textHolder.addChild(tf);				//initially set alpha to zero:		tf.alpha = 0;				textFields.push(tf);	}}function generatePerlinNoise():void {	perlinData.perlinNoise(perlinBaseX,perlinBaseY,octaves,Math.random()*0xFFFFFF,false,true,7);}function startTimer(evt:TweenEvent):void {	this.removeEventListener(Event.ENTER_FRAME, onEnter);		from = (from + 1) % num;	to = (to + 1) % num;		generatePerlinNoise();		holdTimer = new Timer(holdDuration_ms,1);	holdTimer.addEventListener(TimerEvent.TIMER_COMPLETE, startTween);	holdTimer.start();}function startTween(evt:TimerEvent):void {	holdTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, startTween);	parameterTween = new Tween(paramObj,"t",Strong.easeInOut,0,1,tweenDuration);	parameterTween.addEventListener(TweenEvent.MOTION_FINISH, startTimer);	this.addEventListener(Event.ENTER_FRAME, onEnter);}function onEnter(evt:Event):void {	var quad:Number = 4*paramObj.t*(1-paramObj.t);	var alpha0:Number;	var alpha1:Number;		dmf.scaleX = quad*maxDisplacementX;	dmf.scaleY = quad*maxDisplacementY;	blur.blurX = quad*maxBlurX;	blur.blurY = quad*maxBlurY;		if (paramObj.t < xint1) {		alpha0 = 1;		alpha1 = 0;	}	else if (paramObj.t > xint0) {		alpha0 = 0;		alpha1 = 1;	}	else {		alpha0 = m0*(paramObj.t - xint0);		alpha1 = m1*(paramObj.t - xint1);	}			textFields[from].alpha = alpha0;	textFields[to].alpha = alpha1;					//apply the displacement map filter more than once for extra distortion:	textHolder.filters = [blur,dmf,dmf,dmf,blur];		//color change:	colorTrans.redOffset = red[from] + paramObj.t*(red[to] - red[from]);	colorTrans.greenOffset = green[from] + paramObj.t*(green[to] - green[from]);	colorTrans.blueOffset = blue[from] + paramObj.t*(blue[to] - blue[from]);	textHolder.transform.colorTransform = colorTrans;	}//For Visual 2var position:Number = 20;var rot:Number = 0;addEventListener(Event.ENTER_FRAME, onEnterFrame);function onEnterFrame(event:Event):void {		var e1:element1 = new element1();	e1.x = position;	e1.y = position;	e1.rotation = rot;	addChild(e1);	position++;	rot++;	}var secs:Timer = new Timer(1000, 1); secs.addEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete); secs.start();function onTimerComplete(event:TimerEvent):void{     removeEventListener(Event.ENTER_FRAME, onEnterFrame);}//For SpongeDancestop();function clickFrame(button:Sprite, frame:int):void{    button.addEventListener(        MouseEvent.CLICK,        function(e:MouseEvent):void        {            MovieClip(root).gotoAndStop(frame);        }    );}clickFrame(btn1, 1);clickFrame(btn2, 2);clickFrame(btn3, 3);//For Visual1var position:Number = 120;var rot:Number = 0;addEventListener(Event.ENTER_FRAME, onEnterFrame);function onEnterFrame(event:Event):void {       var e1:element1 = new element1();    e1.x = position;    e1.y = position;    e1.rotation = rot;	addChild(e1);	position++;    rot++;}var secs:Timer = new Timer(1000, 3); secs.addEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete); secs.start();function onTimerComplete(event:TimerEvent):void{     removeEventListener(Event.ENTER_FRAME, onEnterFrame);}///*/* Sites Actions*/*///For Introfunction loadProgress(my_content:ProgressEvent):void {		var percent:Number = Math.floor( (my_content.bytesLoaded*100)/my_content.bytesTotal );	loadPercentText.text = percent + " %";	briteDotsMask.width = percent * 3;}function loadComplete(e:Event):void {gotoAndStop(2);}loaderInfo.addEventListener(ProgressEvent.PROGRESS, loadProgress);loaderInfo.addEventListener(Event.COMPLETE, loadComplete);/*// Navigation bar*/import fl.transitions.*;import fl.transitions.easing.*;// tween the main menu into place upon openingvar moveTween:Tween = new Tween(mainmenu_mc, "y", Elastic.easeOut, mainmenu_mc.y, 70, 2, true);// claim MCs from library to use on stage when needed using addChildvar p1:page1 = new page1;var p2:page2 = new page2;var p3:page3 = new page3;var p4:page4 = new page4;pageContainer_mc.addChild(p1);var pageMoveTween:Tween = new Tween(pageContainer_mc, "y", Elastic.easeOut, 300, 110, 2, true);mainmenu_mc.menuBtn1_btn.addEventListener(MouseEvent.CLICK, btn1Click);mainmenu_mc.menuBtn2_btn.addEventListener(MouseEvent.CLICK, btn2Click);mainmenu_mc.menuBtn3_btn.addEventListener(MouseEvent.CLICK, btn3Click);mainmenu_mc.menuBtn4_btn.addEventListener(MouseEvent.CLICK, btn4Click);function btn1Click (event:MouseEvent):void {		var btn1Outro:Tween = new Tween(pageContainer_mc, "alpha", Strong.easeOut, 1, 0, 1, true);	btn1Outro.addEventListener(TweenEvent.MOTION_FINISH, runBtn1Transition);	function runBtn1Transition (event:TweenEvent):void {		pageContainer_mc.removeChildAt(1);		pageContainer_mc.addChild(p1);		var btn1Intro:Tween = new Tween(pageContainer_mc, "alpha", Strong.easeOut, 0, 1, 1, true);	}}function btn2Click (event:MouseEvent):void {		var btn2Outro:Tween = new Tween(pageContainer_mc, "x", Strong.easeIn, pageContainer_mc.x, -500, 1, true);	btn2Outro.addEventListener(TweenEvent.MOTION_FINISH, runBtn2Transition);	function runBtn2Transition (event:TweenEvent):void {		pageContainer_mc.removeChildAt(1);		pageContainer_mc.addChild(p2);		var btn2Intro:Tween = new Tween(pageContainer_mc, "x", Strong.easeOut, pageContainer_mc.x, 56, 1, true);	}}function btn3Click (event:MouseEvent):void {		var btn3Outro:Tween = new Tween(pageContainer_mc, "width", Strong.easeOut, pageContainer_mc.width, 0, 2, true);	btn3Outro.addEventListener(TweenEvent.MOTION_FINISH, runBtn3Transition);	function runBtn3Transition (event:TweenEvent):void {		pageContainer_mc.removeChildAt(1);		pageContainer_mc.addChild(p3);		var btn3Intro:Tween = new Tween(pageContainer_mc, "width", Strong.easeOut, 0, 570, 2, true);	}}function btn4Click (event:MouseEvent):void {	var btn4Outro:Tween = new Tween(pageContainer_mc, "y", Strong.easeIn, pageContainer_mc.y, 500, 1, true);	btn4Outro.addEventListener(TweenEvent.MOTION_FINISH, runBtn4Transition);	function runBtn4Transition (event:TweenEvent):void {		pageContainer_mc.removeChildAt(1);		pageContainer_mc.addChild(p4);		var btn4Intro:Tween = new Tween(pageContainer_mc, "y", Strong.easeOut, 500, 123, 1, true);	}}/*//For Page1*/import flash.media.*;import flash.media.SoundMixer;var swf:MovieClip;var loader:Loader = new Loader();var defaultSWF:URLRequest = new URLRequest("Music.swf");loader.load(defaultSWF);addChild(loader);function btnClick(event:MouseEvent):void{	SoundMixer.soundTransform = new SoundTransform(1);	var newSWFRequest:URLRequest = new URLRequest(event.target.name + ".swf");	loader.load(newSWFRequest);	addChild(loader);}function btnClick2(event:MouseEvent):void{		SoundMixer.soundTransform = new SoundTransform(0); SoundMixer.stopAll();}function btnClick3(event:MouseEvent){	removeChild(loader);}// Btn listenersVisual1.addEventListener(MouseEvent.CLICK, btnClick);TextChange.addEventListener(MouseEvent.CLICK, btnClick)Music.addEventListener(MouseEvent.CLICK, btnClick);StopBtn.addEventListener(MouseEvent.CLICK, btnClick3);Dance.addEventListener(MouseEvent.CLICK, btnClick)StopBtn1.addEventListener(MouseEvent.CLICK, btnClick2)SpongeDance.addEventListener(MouseEvent.CLICK, btnClick)Visual2.addEventListener(MouseEvent.CLICK, btnClick)/*// for boombox taken from developPHP.com*/stop();// Create the sound objectvar snd:Sound = new Sound();// Assign a var name for the sound channelvar channel:SoundChannel;// Boolean value for button functions, to switch in the conditionalsvar isPlaying:Boolean = false;// Set the play buffer to 5 seconds, you can adjust thisvar context:SoundLoaderContext = new SoundLoaderContext(5000, true);// Load the requested URL sound into the snd var, along with contextsnd.load(req, context);// Create the play channel using sndchannel = snd.play(pausePosition); // Start playing// Set "isPalying" to true initiallyisPlaying = true; // make play button show pause symbolplayBtn.gotoAndStop(2);////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// New track play functionfunction newTrack():void {	 if (trackPlayNum < tracksInFolder) {         channel.stop();           trackPlayNum += 1;	     gotoAndPlay(2);	    } else {         channel.stop();           trackPlayNum = 1;	     gotoAndPlay(2);	    }		// Always set pausePosition back to 0 here		pausePosition = 0;} /// Close newTrack function////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Listen for the onPlaybackComplete function directly belowchannel.addEventListener(Event.SOUND_COMPLETE, onPlaybackComplete);// This onPlaybackComplete fires off when tracks finish playingfunction onPlaybackComplete(event:Event) {	// Run the newTrack() function above every time a song completes	newTrack();}///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  Get ID3 info for each track playing ////////////////////snd.addEventListener(Event.ID3, onID3InfoReceived); function onID3InfoReceived (event:Event):void {		var songName:String;	var artist:String;	if (snd.id3.songName != null){		songName = snd.id3.songName;	} else {		songName = "Title Unknown";	}	if (snd.id3.artist != null){		artist = snd.id3.artist;	} else {		artist = "Unknown Artist";	}	// Now here we add the info to the songInfo text on stage	songInfoClip.scrollingText.songInfo_txt.text = songName + "  -  "  + artist;}////// END ID3 Info Gathering////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Play & Pause Function //////////////////////////////////////////////////////function playPause(event:MouseEvent):void {      if (isPlaying == true) {	   	   pausePosition = channel.position;       channel.stop();	   playBtn.gotoAndStop(1);       isPlaying = false;    } else {			        channel = snd.play(pausePosition);	   playBtn.gotoAndStop(2);	   isPlaying = true;	}}////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Play Next Song Function ////////////////////////////////////function nextSound(event:MouseEvent):void {     	 if (trackPlayNum < tracksInFolder) {		          if (snd.bytesLoaded != snd.bytesTotal) {			         channel.stop();					 snd.close();                     trackPlayNum += 1;	                 gotoAndPlay(2);		          } else {			         channel.stop();                       trackPlayNum += 1;	                 gotoAndPlay(2);		          }	    } else {		          if (snd.bytesLoaded != snd.bytesTotal) {			         channel.stop();					 snd.close();                     trackPlayNum = 1;	                gotoAndPlay(2);		          } else {			        channel.stop();                    trackPlayNum = 1;	                gotoAndPlay(2);			          }	    }	 pausePosition = 0;}////////////////////////////////////////////////////////////////////////////////////// Play Previous Song Function //////////////////////////////function previousSound(event:MouseEvent):void {       	 if (trackPlayNum == 1) {		        				if (snd.bytesLoaded != snd.bytesTotal) {			         channel.stop();					 snd.close();                     trackPlayNum += 1;	                 gotoAndPlay(2);		          } else {	                channel.stop();                    trackPlayNum = tracksInFolder;	                gotoAndPlay(2);		          }		 				 } else {		 		          if (snd.bytesLoaded != snd.bytesTotal) {			        channel.stop();					snd.close();                    trackPlayNum -= 1;	                gotoAndPlay(2);			          } else {			        channel.stop();                    trackPlayNum -= 1;	                gotoAndPlay(2);			          }		 	 	 }	 pausePosition = 0;}////////////////////////////////////////////////////////////////////////////////////// Button Listeners ///////////////////////////////////////////////////////////////////////playBtn.addEventListener(MouseEvent.CLICK, playPause);previousBtn.addEventListener(MouseEvent.CLICK, previousSound);nextBtn.addEventListener(MouseEvent.CLICK, nextSound);//autoPlayIcon.addEventListener(MouseEvent.CLICK, toggleAutoPlay);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// AutoPlay Function /////////////////////////////////////////////////////////////////////////////////////////////////////////////////*function toggleAutoPlay ():void {}*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	///////////////   Track Scrubber and Ghost Scrub Knob /////////////////////////////////////////////////////////////////////////////////// ------------------------------------------------------------------ Along with the follower clip inside the trackScrubbervar isDragging:Boolean;trackScrubber.ghostKnob.visible = false;// Set Boundsvar scrubberBounds = new Rectangle(0,trackScrubber.ghostKnob.y,trackScrubber.scrubberRect.width,0);trackScrubber.addEventListener(MouseEvent.MOUSE_DOWN, dragScrub);stage.addEventListener(MouseEvent.MOUSE_UP, dropScrub);         // Drag scrubber		function dragScrub(evt:Event):void {			trackScrubber.ghostKnob.startDrag(true,scrubberBounds);			trackScrubber.ghostKnob.visible = true;            isDragging = true;		}         // Drop scrubber		function dropScrub (evt:Event):void {			             if (isPlaying == true) {				if (isDragging == true) {                     stopDrag();					 // Calculate full time of this track					 var fullTime:int = Math.floor(snd.length / 1000);					 // Claim a var for the position the song is where we release the scrubber after dragging	                 var newPos:Number = fullTime / 100 * Math.floor(trackScrubber.ghostKnob.x * 1000);					 // Important to set new pause position here	                 pausePosition = newPos / 2;					 channel.stop();					 gotoAndPlay(2);	                 //channel = snd.play(newPos);					 isPlaying = true; 					 isDragging = false;				  }				} else { // if not playing					isDragging = false;					 trackScrubber.ghostKnob.visible = false;					//pausePosition = fullTime / 100 * Math.floor(trackScrubber.tBarKnob.x * 1000);				}				}///////////////   End Track Scrubber and Seek Bar ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Add listener to trigger [onEnterFrame] function belowaddEventListener(Event.ENTER_FRAME, onEnterFrame);function onEnterFrame(event:Event):void {		// Set and change volume if they drag    var volumeLevel = channel.soundTransform;	var newLevel:Number = (volumeSlider.knob.x) / -100;	volumeLevel.volume = newLevel;	channel.soundTransform = volumeLevel;	volumeSlider.volumeLightBar.width = volumeSlider.knob.x;	// Set and change pan if they drag	var panLevel = channel.soundTransform;	var newPan:Number = (panSlider.knob.x / 100) - 1;	panLevel.pan = newPan;	channel.soundTransform = panLevel;	    // SPEAKER 1 BOUNCE (left channel)    spkr1.width = ( Math.round(channel.leftPeak * 8) ) + 60; // 60 is speaker width    spkr1.height = ( Math.round(channel.leftPeak * 8) ) + 60; // 60 is speaker height    // SPEAKER 2 BOUNCE (right channel)    spkr2.width = ( Math.round(channel.rightPeak * 8) ) + 60; // 60 is speaker width    spkr2.height = ( Math.round(channel.rightPeak * 8) ) + 60; // 60 is speaker height	// ANIMATED EQ BARS MASK CODE    maskEQ1.width = (Math.round(channel.leftPeak * 27) ); // 27 is the width of the EQ masks    maskEQ2.width = (Math.round(channel.rightPeak * 27) ); // 27 is the width of the EQ masks	bars1.mask = maskEQ1;	bars2.mask = maskEQ2;	// Get full time	var tallytime = (snd.length/1000);	var totalmins:Number = Math.floor(tallytime /60);	var totalsecs = Math.floor (tallytime) % 60;	if (totalsecs < 10){		totalsecs = "0" + totalsecs;	}	displayFullTime.text = ( " " + totalmins+ ":" + totalsecs);	// End get Full time	// Get playing time	var totalSeconds:Number = channel.position/1000;	var minutes:Number = Math.floor(totalSeconds /60);	var seconds = Math.floor (totalSeconds) % 60;	if (seconds < 10){		seconds = "0" + seconds;	}	displayTime.text = ( " " + minutes+ ":" + seconds);	// End get playing time	/// progress bar code...	var estimatedLength:int = Math.ceil(snd.length / (snd.bytesLoaded / snd.bytesTotal));	var playbackPercent:uint = 100 * (channel.position / estimatedLength );	// I want my position bar to be 200 pixels wide on completion so I multiply the percentage x 2	trackScrubber.positionBar.width = playbackPercent * 2;	trackScrubber.follower.x = trackScrubber.positionBar.width;	// make the loaded progress bar that lives under the playhead progress bar grow dynamically	var loadedPercent:uint = 100 * (snd.bytesLoaded / snd.bytesTotal);	trackScrubber.loadedProgressBar.width = loadedPercent * 2;}// Place track amount and current track # into a text fieldsongCount_txt.text = "Track " + trackPlayNum + " of " + tracksInFolder;